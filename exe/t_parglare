#!/usr/bin/env python3

from parglare import Parser, Grammar

# Model:        Header Object;
# Object:       '{' ID Property+ '}';
# Property:     '-' ID '=' Values SemiColon?;
# Property:     '-' ID '=' SemiColon;
# Values:       Value  | Values SemiColon? Value;
# Value:        STRING | INT | FLOAT | GUID | Object | ID;

# STRING: /("(\\"|[^"])*")|(\'(\\\'|[^\'])*\')/;

# // INT and FLOAT are ambiguous. Prefer INT if both match are of same length.
# INT: /[-+]?[0-9]+\b/ {prefer};
# FLOAT: /[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?\b/;

# GUID: /[a-f0-9]*-[a-f0-9]*-[a-f0-9]*-[a-f0-9]*-[a-f0-9]*/;
# SemiColon: ';';
# ID: /[a-zA-Z_][a-zA-Z_0-9]*/;
# Header: /[^\n]*/;


# grammar = r"""
# E: E '+' E  {left, 1}
#  | E '-' E  {left, 1}
#  | E '*' E  {left, 2}
#  | E '/' E  {left, 2}
#  | E '^' E  {right, 3}
#  | '(' E ')'
#  | number;
# number: /\d+(\.\d+)?/;
# """
# actions = {
#     "E": [lambda _, nodes: nodes[0] + nodes[2],
#           lambda _, nodes: nodes[0] - nodes[2],
#           lambda _, nodes: nodes[0] * nodes[2],
#           lambda _, nodes: nodes[0] / nodes[2],
#           lambda _, nodes: nodes[0] ** nodes[2],
#           lambda _, nodes: nodes[1],
#           lambda _, nodes: nodes[0]],
#     "number": lambda _, value: float(value),
# }
# g = Grammar.from_string(grammar)
# parser = Parser(g, debug=True, actions=actions)
# print("Result = ", parser.parse("34 + 4.6 / 2 * 4^2^2 + 78"))

# header = T.m_header + T.inline
# text = Prio(header, T.line + T.NL) * Many
grammar = '''\
text: section*;
section: atom vempty;
atom: header | para;
header: head_mark line;
para: line+;
vempty: NL+;
head_mark: /^%{1,5}\s/;
line: /.*$/;
NL: "\n";
'''
# Text:       Section | Para;
# Section:    /^%.*$/
# Para:       /.*/

text = '''\
some
%% title
para next word
more lines
% t
'''

parser = Parser(Grammar.from_string(grammar))
print(parser.parse(text))
